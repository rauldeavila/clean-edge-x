<!DOCTYPE html>
<html>
<head>
    <meta charset="utf8">
    <link rel="stylesheet" type="text/css" href="../reset.css"></style>
    <script src="./twgl-full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jaames/iro@5"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400;500;600;700&family=Lexend:wght@300;400;500&display=swap" rel="stylesheet">
</head>
<style>
    body {
        background-color: #333;
        font-family: 'Quicksand', sans-serif;
        font-weight: 600;
    }

    .content {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px 70px 50px 70px;
        position: relative;
    }

    .header {
        color: white;
        text-align: center;
        margin-bottom: 15px;
    }

    .header .title {
        font-size: 38px;
        margin-bottom: 5px;
        font-family: 'Lexend', sans-serif;
        font-weight: 500;
    }

    .header .desc {
        font-size: 18px;
        font-style: oblique;
        font-family: 'Lexend', sans-serif;
        font-weight: 300;
    }


    #main {
        position: relative;
        display: flex;
        flex-wrap: wrap;
        max-width: 100%;
        margin-bottom: 30px;
        justify-content: center;
        user-select: none;
        padding: 0;
    }

    .uploadContainer {
        position: absolute;
        left: -530px;
        right: 0;
        margin: auto;
        top: -60px;
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    .uploadContainer .button {
        padding: 10px 15px;
        font-size: 16px;
        width: unset;
        margin-bottom: 4px;
        box-shadow: 0 6px #bcc0cd;
    }
    .uploadContainer .button:active {
        margin-top: 4px;
        margin-bottom: 0;
        box-shadow: 0 2px #bcc0cd;
    }
    .uploadContainer .desc {
        margin-top: 4px;
        color: white;
    }
    #uploadInput {
        display: none;
    }

    .rotateContainer {
        position: relative;
        border: 4px solid white;
        border-radius: 10px;
        /* flex: 1; */
        margin-right: -20px;
        margin-bottom: -20px;
        z-index: 1;
        background-color: #333;
        box-shadow: inset 0 0 30px black;
    }

    .controls {
        position: absolute;
        width: 100%;
        height: 100%;
    }

    #dropArea {
        position: absolute;
        width: 100%;
        height: 100%;
        z-index: 100;
        touch-action: none;
    }
    #dropArea.hover {
        background-color: rgba(41, 173, 250, 0.5);
    }

    #canvasContainer {
        width: 416px;
        height: 416px;
        position: relative;
        overflow: hidden;
        filter: drop-shadow(0 3px 8px #000000d3);
        border-radius: 8px;
    }

    #rotate {
        /* width: 400px; */
        /* height: 400px; */
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        margin: auto;

        /* filter: drop-shadow(0 1.5px 2px #000000d3); */
    }
    .rotate #rotate {
        transform: scale(4);
        image-rendering: pixelated;
    }

    #options {
        flex: 1;
        flex-basis: 100px;
        display: flex;
        flex-wrap: wrap;
        /* min-width: 40px; */
        /* min-height: 40px; */
        max-width: 100%;
        max-height: 100%;
        background-color: white;
        border-radius: 10px;
        padding-bottom: 8px;
        padding-right: 8px;
        margin-bottom: -20px;
        margin-right: -20px;
        margin-top: 0;
        justify-content: space-around;
        align-items: center;
        padding-top: 6px;
    }

    .option {
        min-width: 100px;
        min-height: 50px;
        margin-left: 20px;
        margin-top: 20px;
        padding: 8px;
        background-color: #e1e4f1;
        float: left;
        display: flex;
        align-items: center;
        flex-direction: column;
        border-radius: 10px;
        box-shadow: inset 0 0 17px #1c1d2442;
        position: relative;
    }
    .scale .option[mode="rotate"] {
        display: none;
    }
    .rotate .option[mode="scale"] {
        display: none;
    }
    .option input {
        margin: 8px;
    }
    .option input[type="number"], .option input[type="text"] {
        all: unset;
        width: 50px;
        height: 24px;
        background-color: white;
        border-radius: 3px;
        padding: 2px 8px;
        margin: 8px 28px;
        text-align: center;
        box-shadow: 0 3px 8px #1c1d2442;
    }
    .option input[type="range"] {
        margin-top: 0;
        width: 100px;
    }

    .option .desc {
        text-align: center;
    }

    .option .desc2 {
        color: #333;
        font-size: 12px;
    }

    .resetContainer {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        justify-content: center;
    }

    .reset {
        width: 24px;
        height: 24px;
        background: url(reset.svg) center no-repeat;
        opacity: 0.7;
        cursor: pointer;
        margin-bottom: -34px;
        margin-left: -98px;
        margin-top: 10px;
    }
    .reset:active {
        opacity: 1.0;
    }

    .reset.equal {
        margin-left: 0;
        margin-right: -98px;
        background: url(equal.svg) center no-repeat;
    }

    .switch {
        position: relative;
        display: inline-block;
        width: 52px;
        height: 28px;
        background-color: rgba(0, 0, 0, 0.25);
        border-radius: 20px;
        transition: all 0.3s;
        margin: 8px;
        box-shadow: 0 3px 8px #1c1d2442;
    }
    .switch::after {
        content: '';
        position: absolute;
        width: 18px;
        height: 18px;
        border-radius:50%;
        background-color: white;
        top: 5px;
        left: 5px;
        transition: all 0.3s;
    }

    .checkbox:checked + .switch::after {
        left : 28px;
    }
    .checkbox:checked + .switch {
        background-color: rgb(32 157 255);
    }
    .checkbox {
        display : none;
    }

    #colorPickerContainer {
        display: none;
        position: absolute;
        width: 0;
        height: 0;
        align-items: center;
        flex-direction: column;
    }
    #colorPickerContainer.active {
        display: flex;
    }
    #colorPicker {
        z-index: 400;
        background-color: #00000052;
        padding: 16px;
        border-radius: 30px;
        backdrop-filter: blur(2px);
        /* flex: 0 0 312px; */
        position: relative;
        top: 28px;
        box-shadow: 0 4px 7px 4px #00000094;
    }
    #colorPicker:before {
        content: '';
        width: 0;
        height: 0;
        position: absolute;
        top: -10px;
        left: 0;
        right: 0;
        margin: auto;
        border-left: 10px solid transparent;
        border-right: 10px solid transparent;
        border-bottom: 10px solid #3a3a3d;
    }
    .colorContainer {
        width: 34px;
        height: 34px;
        background-color: white;
        border-radius: 500px;
        margin: 8px;
        overflow: hidden;
        border: 4px solid white;
        cursor: pointer;
        box-shadow: 0 3px 8px #1c1d2442;
    }

    .button {
        padding: 14px 20px;
        background-color: white;
        color: #333;
        font-size: 18px;
        font-weight: 800;
        border-radius: 10px;
        box-shadow: 0 8px #bcc0cd;
        user-select: none;
        cursor: pointer;
        margin-bottom: 6px;
        transition: all 0.1s cubic-bezier(0,0.3,0,1);
    }
    .button:active {
        margin-top: 6px;
        margin-bottom: 0;
        box-shadow: 0 2px #bcc0cd;
    }

    .modeContainer {
        padding: 16px;
        padding-bottom: 36px;
        margin-bottom: -20px;
        border-radius: 10px;
        background-color: white;
        text-align: center;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .modeContainer .title {
        font-size: 18px;
        margin-right: 10px;
        margin-bottom: 0;
    }

    #modeSwitch {
        display: flex;
        align-items: center;
        position: relative;
        border-radius: 8px;
        background-color: #c1cee3;
        font-size: 20px;
        user-select: none;
        box-shadow: inset 0 0 17px #1c1d2442;
        z-index: 2;
    }
    #modeSwitch .slider {
        position: absolute;
        width: 100px;
        height: 40px;
        background-color: rgb(32 157 255);
        border-radius: 8px;
        bottom: 4px;
        box-shadow: 0 4px rgb(5 121 213);
        overflow: hidden;
        left: 0;
        transition: left 0.1s ease-out,  top 0.1s ease-out;
    }
    #modeSwitch.right .slider {
        left: 100px;
    }
    #modeSwitch .mode {
        width: 100px;
        height: 40px;
        line-height: 37px;
        cursor: pointer;
        color: #555;
        top: 0;
    }
    #modeSwitch .slider .mode {
        position: absolute;
        width: 100px;
        height: 40px;
        line-height: 37px;
        cursor: pointer;
        color: white;
        transition: left 0.1s ease-out, top 0.1s ease-out;
        left: 0px;
        top: 0;
    }
    #modeSwitch .slider .mode:nth-child(2) {
        left: 100px;
        top: 5px;
    }
    #modeSwitch.right .slider .mode:nth-child(1) {
       left: -100px;
       top: 5px;
    }
    #modeSwitch.right .slider .mode:nth-child(2) {
       left: 0px;
       top: 0;
    }

    .exampleContainer {
        position: absolute;
        left: -80px;
        width: 200px;
        background-color: white;
        border-radius: 12px;
        text-align: center;
        padding: 10px;
        padding-right: 130px;
        box-sizing: border-box;
    }
    /* .exampleContainer {
        position: absolute;
        left: 0;
        right: -530px;
        margin: auto;
        top: -60px;
        display: flex;
        flex-direction: column;
        align-items: center;
    } */
    .examples {
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    .examples .example {
        width: 36px;
        height: 36px;
        background-color: rgb(32 157 255);
        box-shadow: 0 4px rgb(5 121 213);
        border-radius: 6px;
        margin: 6px;
        margin-top: 8px;
        cursor: pointer;
        transition: all 0.1s cubic-bezier(0,0.3,0,1);
        line-height: 36px;
        color: white;
    }
    .examples .example:active {
        margin-top: 10px;
        margin-bottom: 4px;
        box-shadow: 0 2px rgb(5 121 213);
    }

    strong {
        font-weight: 600;
    }

    .info {
        margin-top: 40px;
        color: white;
        font-size: 18px;
        max-width: 800px;
        font-weight: 400;
        line-height: 24px;
    }

    ul {

    }
    li strong {
        font-size: 20px;
    }
    li {
        margin: 12px 0 12px 20px;
        font-size: 18px;
    }

    a {
        color: rgb(68, 174, 255);
    }

    .thumbnail-container {
        margin: 5px;
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    .thumbnail {
        width: 70px;
        height: 70px;
        object-fit: contain;
        background-color: #444;
        border-radius: 8px;
        cursor: pointer;
        border: 3px solid transparent;
        transition: border-color 0.2s;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
    }

    .thumbnail.active {
        border-color: rgb(32, 157, 255);
    }

    .thumbnail-delete {
        position: absolute;
        top: -10px;
        right: -10px;
        width: 24px;
        height: 24px;
        background-color: #ff3b3b;
        color: white;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
    }

    #imagesContainer {
        display: flex;
        flex-direction: column;
        position: absolute;
        left: -200px;
        top: 10px;
        max-height: 600px;
        overflow-y: auto;
        width: 85px;
        z-index: 5;
        padding: 5px;
        padding-top: 30px;
        background-color: rgba(30, 30, 30, 0.5);
        border-radius: 10px;
        backdrop-filter: blur(2px);
    }

    #imagesContainer::before {
        content: "Images";
        position: absolute;
        top: 5px;
        left: 0;
        right: 0;
        text-align: center;
        color: white;
        font-size: 14px;
        padding-bottom: 5px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.3);
    }

    #imagesContainer::-webkit-scrollbar {
        width: 6px;
    }

    #imagesContainer::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.1);
        border-radius: 3px;
    }

    #imagesContainer::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.3);
        border-radius: 3px;
    }

    #imagesContainer::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.5);
    }

    .option[name="lineWidth"] {
        min-width: 100px;
        position: relative;
        padding-bottom: 8px;
    }

    .option[name="lineWidth"] input[type="text"] {
        margin: 8px auto;
        z-index: 1;
        position: relative;
    }

    .option[name="lineWidth"] .reset {
        position: absolute;
        margin: 0;
        top: 40px;
        right: 16px;
    }
</style>
<body>
    <div id="colorPickerContainer">
        <div id="colorPicker"></div>
    </div>
    <div class="content">
        <div class="header">
            <div class="title">cleanEdge</div>
        </div>
        <div class="modeContainer">
            <div class="title">mode:</div>
            <div id="modeSwitch" class="right">
                <div class="slider">
                    <div class="mode">rotation</div>
                    <div class="mode">scaling</div>
                </div>
                <div class="mode">rotation</div>
                <div class="mode">scaling</div>
            </div>
        </div>
        <div id="main" class="scale">
            <div id="imagesContainer"></div>
            <div class="uploadContainer">
                <div id="upload" class="button">upload images</div>
                <input type="file" id="uploadInput" multiple>
            </div>
            <div class="rotateContainer">
                <div id="dropArea"></div>
                <div class="controls"></div>
                <div id="canvasContainer">
                    <canvas id="rotate"></canvas>
                </div>
            </div>
            <div id="options">
                <div class="option" name="angle" mode="rotate">
                    <div class="desc">angle</div>
                    <div class="reset" onclick="angle = 0; updateAngle()"></div>
                    <input type="text" class="display" value="0">
                </div>
                <div class="option" name="scale" mode="scale">
                    <div class="desc">scale</div>
                    <div class="reset" onclick="zoomStage = 2; updateZoom()"></div>
                    <input type="text" class="display" value="4">
                </div>
                <div class="option" name="enable">
                    <div class="desc">toggle</div>
                    <!-- <input type="checkbox"> -->
                    <input type="checkbox" class="checkbox" id="toggle" checked oninput="this.nextElementSibling.nextElementSibling.textContent = this.checked ? '(cleanEdge)' : '(basic rotation)'"/>
                    <label for="toggle" class="switch"></label>
                    <div class="desc2">(cleanEdge)</div>
                </div>
                <div class="option" name="slope" mode="scale">
                    <div class="desc">slopes</div>
                    <input type="checkbox" class="checkbox" id="slope" checked/>
                    <label for="slope" class="switch"></label>
                </div>
                <div class="option" name="highestColor">
                    <div class="desc">highest color</div>
                    <div class="colorContainer"><div type="color" class="control"></div></div>
                </div>
                <!-- <div class="option" name="similarThreshold">
                    <div class="desc">similar color<br/>threshold</div>
                    <input type="text" class="display" value="1" oninput="if(parseFloat(this.value) >= 0) this.nextElementSibling.value = parseFloat(this.value)">
                    <input type="range" min="0" max="3" step="0.01" oninput="this.previousElementSibling.value = this.value">
                </div> -->
                <div class="option lineWidth" name="lineWidth">
                    <div class="desc">line width</div>
                    <div class="reset equal" style="display: none;" title="reset to diagonal" onclick="lineWidthInput.value = 0.707; updateLineWidth(0.707);"></div>
                    <input id="lineWidthInput" type="text" class="display" value="1" oninput="updateLineWidth(this.value)" style="margin: 8px auto;">
                    <input id="lineWidthRange" type="range" min="0" max="2" step="0.01" style="display: none;" value="1">
                </div>
            </div>
        </div>
        <div id="dnld" class="button" style="margin-top: 30px !important;">download scaled</div>
        <div id="downloadAll" class="button" style="display: none;">download all</div>
    </div>
</body>
<script id="vs" type="x-shader/vertex">
    #version 300 es
    precision highp float;
    uniform mat4 u_worldViewProjection;

    in vec4 position;
    in vec2 a_texcoord;
    out vec2 v_texCoord;
    void main() {
        v_texCoord = a_texcoord;
        gl_Position = u_worldViewProjection * position;
    }
</script>
<script id="fs" type="x-shader/fragment" >
    #version 300 es

    precision highp float;
    uniform vec2 iResolution;
    uniform sampler2D iChannel0;

    //enables 2:1 slopes. otherwise only uses 45 degree slopes
    //#define SLOPE
    uniform bool SLOPE;
    //cleans up small detail slope transitions (if SLOPE is enabled)
    #define CLEANUP

    //the color with the highest priority.
    // other colors will be tested based on distance to this
    // color to determine which colors take priority for overlaps.
    uniform vec3 highestColor;// = vec3(1.,1.,1.);

    //how close two colors should be to be considered "similar".
    // can group shapes of visually similar colors, but creates
    // some artifacting and should be kept as low as possible.
    uniform float similarThreshold;// = 0.0;

    uniform float lineWidth;// = 1.0;

    const float scale = 4.0;


    bool similar(vec4 col1, vec4 col2){
        return (col1.a == 0. && col2.a == 0.) || distance(col1, col2) <= similarThreshold;
    }

    //multiple versions because godot doesn't support function overloading
    //note: inner check should ideally check between all permutations
    //  but this is good enough, and faster
    bool similar3(vec4 col1, vec4 col2, vec4 col3){
        return similar(col1, col2) && similar(col2, col3);
    }

    bool similar4(vec4 col1, vec4 col2, vec4 col3, vec4 col4){
        return similar(col1, col2) && similar(col2, col3) && similar(col3, col4);
    }

    bool similar5(vec4 col1, vec4 col2, vec4 col3, vec4 col4, vec4 col5){
        return similar(col1, col2) && similar(col2, col3) && similar(col3, col4) && similar(col4, col5);
    }

    bool higher(vec4 thisCol, vec4 otherCol){
        if(similar(thisCol, otherCol)) return false;
        if(thisCol.a == otherCol.a){
            return distance(thisCol.rgb, highestColor) < distance(otherCol.rgb, highestColor);
        } else {
            return thisCol.a > otherCol.a;
        }
    }

    vec4 higherCol(vec4 thisCol, vec4 otherCol){
        return higher(thisCol, otherCol) ? thisCol : otherCol;
    }

    //color distance
    float cd(vec4 col1, vec4 col2){
        return distance(col1.rgba, col2.rgba);
    }

    float distToLine(vec2 testPt, vec2 pt1, vec2 pt2, vec2 dir){
      vec2 lineDir = pt2 - pt1;
      vec2 perpDir = vec2(lineDir.y, -lineDir.x);
      vec2 dirToPt1 = pt1 - testPt;
    //  return (dot(normalize(perpDir), dirToPt1));
      return (dot(perpDir, dir) > 0.0 ? 1.0 : -1.0) * (dot(normalize(perpDir), dirToPt1));
    }

    //based on down-forward direction
    vec4 sliceDist(vec2 point, vec2 mainDir, vec2 pointDir, vec4 u, vec4 uf, vec4 uff, vec4 b, vec4 c, vec4 f, vec4 ff, vec4 db, vec4 d, vec4 df, vec4 dff, vec4 ddb, vec4 dd, vec4 ddf){
        float minWidth = 0.0;
        float maxWidth = 1.4;
        if(SLOPE){
            minWidth = 0.44;
            maxWidth = 1.142;
        }
        float _lineWidth = max(minWidth, min(maxWidth, lineWidth));
        point = mainDir * (point - 0.5) + 0.5; //flip point

        //edge detection
        float distAgainst = 4.0*cd(f,d) + cd(uf,c) + cd(c,db) + cd(ff,df) + cd(df,dd);
		float distTowards = 4.0*cd(c,df) + cd(u,f) + cd(f,dff) + cd(b,d) + cd(d,ddf);
		bool shouldSlice =
			(distAgainst < distTowards)
			|| (distAgainst < distTowards + 0.001) && !higher(c, f); //equivalent edges edge case
		if(similar4(f, d, b, u) && similar3(uf, df, db/*, ub*/) && !similar(c, f)){ //checkerboard edge case
			shouldSlice = false;
		}
        if(!shouldSlice) return vec4(-1.0);

        //only applicable for very large lineWidth (>1.3)
    //	if(similar3(c, f, df)){ //don't make slice for same color
    //		return vec4(-1.0);
    //	}
        float dist = 1.0;
        bool flip = false;
        vec2 center = vec2(0.5,0.5);


        if(SLOPE && similar3(f, d, db) && !similar3(f, d, b) && !similar(uf, db)){ //lower shallow 2:1 slant
            if(similar(c, df) && higher(c, f)){ //single pixel wide diagonal, dont flip

            } else {
                //priority edge cases
                if(higher(c, f)){
                    flip = true;
                }
                if(similar(u, f) && !similar(c, df) && !higher(c, u)){
                    flip = true;
                }
            }

            if(flip){
                dist = _lineWidth-distToLine(point, center+vec2(1.5, -1.0)*pointDir, center+vec2(-0.5, 0.0)*pointDir, -pointDir); //midpoints of neighbor two-pixel groupings
            } else {
                dist = distToLine(point, center+vec2(1.5, 0.0)*pointDir, center+vec2(-0.5, 1.0)*pointDir, pointDir); //midpoints of neighbor two-pixel groupings
            }

            //cleanup slant transitions
            #ifdef CLEANUP
            if(!flip && similar(c, uf) && !(similar3(c, uf, uff) && !similar3(c, uf, ff) && !similar(d, uff))){ //shallow
                float dist2 = distToLine(point, center+vec2(2.0, -1.0)*pointDir, center+vec2(-0.0, 1.0)*pointDir, pointDir);
                dist = min(dist, dist2);
            }
            #endif

            dist -= (_lineWidth/2.0);
            return dist <= 0.0 ? ((cd(c,f) <= cd(c,d)) ? f : d) : vec4(-1.0);
        } else if(SLOPE && similar3(uf, f, d) && !similar3(u, f, d) && !similar(uf, db)){ //forward steep 2:1 slant
            if(similar(c, df) && higher(c, d)){ //single pixel wide diagonal, dont flip

            } else {
                //priority edge cases
                if(higher(c, d)){
                    flip = true;
                }
                if(similar(b, d) && !similar(c, df) && !higher(c, d)){
                    flip = true;
                }
            }

            if(flip){
                dist = _lineWidth-distToLine(point, center+vec2(0.0, -0.5)*pointDir, center+vec2(-1.0, 1.5)*pointDir, -pointDir); //midpoints of neighbor two-pixel groupings
            } else {
                dist = distToLine(point, center+vec2(1.0, -0.5)*pointDir, center+vec2(0.0, 1.5)*pointDir, pointDir); //midpoints of neighbor two-pixel groupings
            }

            //cleanup slant transitions
            #ifdef CLEANUP
            if(!flip && similar(c, db) && !(similar3(c, db, ddb) && !similar3(c, db, dd) && !similar(f, ddb))){ //steep
                float dist2 = distToLine(point, center+vec2(1.0, 0.0)*pointDir, center+vec2(-1.0, 2.0)*pointDir, pointDir);
                dist = min(dist, dist2);
            }
            #endif

            dist -= (_lineWidth/2.0);
            return dist <= 0.0 ? ((cd(c,f) <= cd(c,d)) ? f : d) : vec4(-1.0);
        } else
        if(similar(f, d)) { //45 diagonal
            if(similar(c, df) && higher(c, f)){ //single pixel diagonal along neighbors, dont flip
                if(!similar(c, dd) && !similar(c, ff)){ //line against triple color stripe edge case
                    flip = true;
                }
            } else {
                //priority edge cases
                if(higher(c, f)){
                    flip = true;
                }
                if(!similar(c, b) && similar4(b, f, d, u)){
                    flip = true;
                }
            }
            //single pixel 2:1 slope, dont flip
            if((( (similar(f, db) && similar3(u, f, df)) || (similar(uf, d) && similar3(b, d, df)) ) && !similar(c, df))){
                flip = true;
            }

            if(flip){
                dist = _lineWidth-distToLine(point, center+vec2(1.0, -1.0)*pointDir, center+vec2(-1.0, 1.0)*pointDir, -pointDir); //midpoints of own diagonal pixels
            } else {
                dist = distToLine(point, center+vec2(1.0, 0.0)*pointDir, center+vec2(0.0, 1.0)*pointDir, pointDir); //midpoints of corner neighbor pixels
            }

            //cleanup slant transitions
            if(SLOPE){
                #ifdef CLEANUP
                if(!flip && similar3(c, uf, uff) && !similar3(c, uf, ff) && !similar(d, uff)){ //shallow
                    float dist2 = distToLine(point, center+vec2(1.5, 0.0)*pointDir, center+vec2(-0.5, 1.0)*pointDir, pointDir);
                    dist = max(dist, dist2);
                }

                if(!flip && similar3(ddb, db, c) && !similar3(dd, db, c) && !similar(ddb, f)){ //steep
                    float dist2 = distToLine(point, center+vec2(1.0, -0.5)*pointDir, center+vec2(0.0, 1.5)*pointDir, pointDir);
                    dist = max(dist, dist2);
                }
                #endif
            }

            dist -= (_lineWidth/2.0);
            return dist <= 0.0 ? ((cd(c,f) <= cd(c,d)) ? f : d) : vec4(-1.0);
        }
        else if(SLOPE && similar3(ff, df, d) && !similar3(ff, df, c) && !similar(uff, d)){ //far corner of shallow slant

            if(similar(f, dff) && higher(f, ff)){ //single pixel wide diagonal, dont flip

            } else {
                //priority edge cases
                if(higher(f, ff)){
                    flip = true;
                }
                if(similar(uf, ff) && !similar(f, dff) && !higher(f, uf)){
                    flip = true;
                }
            }
            if(flip){
                dist = _lineWidth-distToLine(point, center+vec2(1.5+1.0, -1.0)*pointDir, center+vec2(-0.5+1.0, 0.0)*pointDir, -pointDir); //midpoints of neighbor two-pixel groupings
            } else {
                dist = distToLine(point, center+vec2(1.5+1.0, 0.0)*pointDir, center+vec2(-0.5+1.0, 1.0)*pointDir, pointDir); //midpoints of neighbor two-pixel groupings
            }

            dist -= (_lineWidth/2.0);
            return dist <= 0.0 ? ((cd(f,ff) <= cd(f,df)) ? ff : df) : vec4(-1.0);
        } else if(SLOPE && similar3(f, df, dd) && !similar3(c, df, dd) && !similar(f, ddb)){ //far corner of steep slant
            if(similar(d, ddf) && higher(d, dd)){ //single pixel wide diagonal, dont flip

            } else {
                //priority edge cases
                if(higher(d, dd)){
                    flip = true;
                }
                if(similar(db, dd) && !similar(d, ddf) && !higher(d, dd)){
                    flip = true;
                }
    //			if(!higher(d, dd)){
    //				return vec4(1.0);
    //				flip = true;
    //			}
            }

            if(flip){
                dist = _lineWidth-distToLine(point, center+vec2(0.0, -0.5+1.0)*pointDir, center+vec2(-1.0, 1.5+1.0)*pointDir, -pointDir); //midpoints of neighbor two-pixel groupings
            } else {
                dist = distToLine(point, center+vec2(1.0, -0.5+1.0)*pointDir, center+vec2(0.0, 1.5+1.0)*pointDir, pointDir); //midpoints of neighbor two-pixel groupings
            }
            dist -= (_lineWidth/2.0);
            return dist <= 0.0 ? ((cd(d,df) <= cd(d,dd)) ? df : dd) : vec4(-1.0);
        }
        return vec4(-1.0);
    }


    // v ONLY FOR DEMO v //

    uniform bool enable;
    uniform bool scaling;

    // ^ ONLY FOR DEMO ^ //

    in vec2 v_texCoord;
    out vec4 fragColor;
    void main() {
        vec2 fragCoord = gl_FragCoord.xy;
        fragCoord = v_texCoord*iResolution.xy;

        // v ONLY FOR DEMO v //
        if(scaling) fragCoord += 0.0001;
        // ^ ONLY FOR DEMO ^ //

        vec2 size = iResolution.xy+0.5;
        vec2 px = fragCoord.xy;
        vec2 local = fract(px);
        px = ceil(px);

        vec2 pointDir = round(local)*2.0-1.0;

        //neighbor pixels
        //Up, Down, Forward, and Back
        //relative to quadrant of current location within pixel

        vec4 uub = texture(iChannel0, (px+vec2(-1.0,-2.0)*pointDir)/size);
        vec4 uu  = texture(iChannel0, (px+vec2( 0.0,-2.0)*pointDir)/size);
        vec4 uuf = texture(iChannel0, (px+vec2( 1.0,-2.0)*pointDir)/size);

        vec4 ubb = texture(iChannel0, (px+vec2(-2.0,-2.0)*pointDir)/size);
        vec4 ub  = texture(iChannel0, (px+vec2(-1.0,-1.0)*pointDir)/size);
        vec4 u   = texture(iChannel0, (px+vec2( 0.0,-1.0)*pointDir)/size);
        vec4 uf  = texture(iChannel0, (px+vec2( 1.0,-1.0)*pointDir)/size);
        vec4 uff = texture(iChannel0, (px+vec2( 2.0,-1.0)*pointDir)/size);

        vec4 bb  = texture(iChannel0, (px+vec2(-2.0, 0.0)*pointDir)/size);
        vec4 b   = texture(iChannel0, (px+vec2(-1.0, 0.0)*pointDir)/size);
        vec4 c   = texture(iChannel0, (px+vec2( 0.0, 0.0)*pointDir)/size);
        vec4 f   = texture(iChannel0, (px+vec2( 1.0, 0.0)*pointDir)/size);
        vec4 ff  = texture(iChannel0, (px+vec2( 2.0, 0.0)*pointDir)/size);

        vec4 dbb = texture(iChannel0, (px+vec2(-2.0, 1.0)*pointDir)/size);
        vec4 db  = texture(iChannel0, (px+vec2(-1.0, 1.0)*pointDir)/size);
        vec4 d   = texture(iChannel0, (px+vec2( 0.0, 1.0)*pointDir)/size);
        vec4 df  = texture(iChannel0, (px+vec2( 1.0, 1.0)*pointDir)/size);
        vec4 dff = texture(iChannel0, (px+vec2( 2.0, 1.0)*pointDir)/size);

        vec4 ddb = texture(iChannel0, (px+vec2(-1.0, 2.0)*pointDir)/size);
        vec4 dd  = texture(iChannel0, (px+vec2( 0.0, 2.0)*pointDir)/size);
        vec4 ddf = texture(iChannel0, (px+vec2( 1.0, 2.0)*pointDir)/size);

        vec4 col = c;

        //c_orner, b_ack, and u_p slices
        // (slices from neighbor pixels will only reach these 3 quadrants
        vec4 c_col = sliceDist(local, vec2( 1.0, 1.0), pointDir, u, uf, uff, b, c, f, ff, db, d, df, dff, ddb, dd, ddf);
        vec4 b_col = sliceDist(local, vec2(-1.0, 1.0), pointDir, u, ub, ubb, f, c, b, bb, df, d, db, dbb, ddf, dd, ddb);
        vec4 u_col = sliceDist(local, vec2( 1.0,-1.0), pointDir, d, df, dff, b, c, f, ff, ub, u, uf, uff, uub, uu, uuf);

        if(c_col.r >= 0.0){
            col = c_col;
        }
        if(b_col.r >= 0.0){
            col = b_col;
        }
        if(u_col.r >= 0.0){
            col = u_col;
        }


        //fragColor = col;

        // v ONLY FOR DEMO v //
        if(enable){
            fragColor = col;
        } else {
            fragColor = c;
        }
        // ^ ONLY FOR DEMO ^ //
    }

</script>
<script>
    let mainEl = document.getElementById('main');
    let optionsEl = document.getElementById('options');

    let uploadEl = document.getElementById('upload');
    let uploadInputEl = document.getElementById('uploadInput');
    let downloadEl = document.getElementById('dnld');

    let mode = 'scale';
    let modeSwitchEl = document.getElementById('modeSwitch');
    modeSwitchEl.addEventListener('click', (e) => {
        modeSwitchEl.classList.remove('right');
        mainEl.classList.remove('scale', 'rotate');
        if(mode === 'rotate'){
            mode = 'scale';
            downloadEl.textContent = 'download scaled'
            modeSwitchEl.classList.add('right');
        } else {
            mode = 'rotate';
            downloadEl.textContent = 'download rotated'
        }
        mainEl.classList.add(mode);
        update();
    });


    const canvas = document.getElementById("rotate");
    const container = document.getElementById("canvasContainer");
    const size = 1.5;
    let viewSize = 1.5;
    let size2 = 1.5;
    let roundFix = {x:0,y:0};
    const displaySize = 1.5;
    let s = 1/size;
    let pos = {x:1.0, y:1.0};

    let side = 1.0;
    let displaySide = 1.0;

    let textures;
    let image = new Image();

    // Array to store all loaded images and their processed results
    let images = [];
    let currentImageIndex = -1;
    let defaultImageLoaded = false;

    let width = 1.0;
    let height = 1.0;

    let angle = 0;
    let zoom = 4.0;
    let zoomStage = 2.0;
    let zoomOffset = {x:0.0, y:0.0};

    let EXPORT_SCALE = false;

    let highestColor = [1.0,1.0,1.0];
    let optionEls = {
        angle: document.querySelector('.option[name="angle"] input'),
        scale: document.querySelector('.option[name="scale"] input'),
        enable: document.querySelector('.option[name="enable"] input'),
        similarThreshold: document.querySelector('.option[name="similarThreshold"] input'),
        lineWidth: document.querySelector('.option[name="lineWidth"] input'),
        slope: document.querySelector('.option[name="slope"] input'),
    }

    let lineWidthValue = 1;

    function updateLineWidth(value) {
        const parsedValue = parseFloat(value);
        if (!isNaN(parsedValue)) {
            lineWidthValue = Math.max(0, Math.min(2, parsedValue));
            // Update the input if the value was clamped
            if (lineWidthValue.toString() !== value) {
                document.getElementById('lineWidthInput').value = lineWidthValue;
            }
        }
    }

    const gl = canvas.getContext("webgl2", {antialias: false, preserveDrawingBuffer:true});
    // gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    const programInfo = twgl.createProgramInfo(gl, ["vs", "fs"]);

    let arrays = {
        position: { numComponents: 3, data: [-pos.x, -pos.y, 0, pos.y, -pos.x, 0, -pos.x, pos.y, 0, -pos.y, pos.x, 0, pos.x, -pos.y, 0, pos.y, pos.x, 0], },
        a_texcoord: { numComponents: 2, data: [0, 0, 1, 0, 0, 1,   0,1, 1,0, 1,1],                 },
    };
    let bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);

    init();

    function render(time) {
        // twgl.resizeCanvasToDisplaySize(gl.canvas);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.viewport(0, 0, viewSize, viewSize);

        if(EXPORT_SCALE){
            viewSize = zoom * side;
            canvas.width = viewSize;
            canvas.height = viewSize;
            // zoomOffset = {x:0, y:0}
        }

        const uniforms = {
            iResolution: [image.width, image.height],
            u_worldViewProjection: twgl.m4.identity(),

            highestColor,
            similarThreshold: optionEls.similarThreshold && parseFloat(optionEls.similarThreshold.value) || 0,
            lineWidth: lineWidthValue,
            SLOPE: mode === 'rotate' || optionEls.slope && optionEls.slope.checked,
            enable: optionEls.enable && optionEls.enable.checked,
            scaling: mode === 'scale'
        };

        // uniforms.u_worldViewProjection = twgl.m4.translate(uniforms.u_worldViewProjection, twgl.v3.create(offset.x,offset.y,0.0));
        if(mode === 'rotate'){
            uniforms.u_worldViewProjection = twgl.m4.rotateZ(uniforms.u_worldViewProjection, -angle);
            uniforms.u_worldViewProjection = twgl.m4.scale(uniforms.u_worldViewProjection, twgl.v3.create((1/(viewSize)),(1/(viewSize)),));
            uniforms.u_worldViewProjection = twgl.m4.scale(uniforms.u_worldViewProjection, twgl.v3.create(1, -1, 1));
            uniforms.u_worldViewProjection = twgl.m4.translate(uniforms.u_worldViewProjection, twgl.v3.create(roundFix.x,roundFix.y,0.0));
        } else if(mode === 'scale'){
            uniforms.u_worldViewProjection = twgl.m4.scale(uniforms.u_worldViewProjection, twgl.v3.create((1/(viewSize)),(1/(viewSize)),));
            uniforms.u_worldViewProjection = twgl.m4.scale(uniforms.u_worldViewProjection, twgl.v3.create(1, -1, 1));
            uniforms.u_worldViewProjection = twgl.m4.scale(uniforms.u_worldViewProjection, twgl.v3.create(zoom, zoom, 1));
            if(!EXPORT_SCALE){

                if(zoom == 1 || zoom == 2){
                    uniforms.u_worldViewProjection = twgl.m4.translate(uniforms.u_worldViewProjection, twgl.v3.create(Math.round(zoomOffset.x/2)*2, Math.round(zoomOffset.y/2)*2, 0.0));
                } else {
                    uniforms.u_worldViewProjection = twgl.m4.translate(uniforms.u_worldViewProjection, twgl.v3.create(zoomOffset.x, zoomOffset.y, 0.0));
                }
                uniforms.u_worldViewProjection = twgl.m4.translate(uniforms.u_worldViewProjection, twgl.v3.create(roundFix.x,roundFix.y,0.0));
            }

        }

        gl.useProgram(programInfo.program);
        twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);
        twgl.setUniforms(programInfo, uniforms);

        twgl.drawBufferInfo(gl, bufferInfo);

        requestAnimationFrame(render);
    }
    requestAnimationFrame(render);


    image.onload = () => {
        textures = twgl.createTextures(gl, {
            iChannel0: { src: () => image, minMag: gl.NEAREST, wrap:gl.CLAMP_TO_EDGE },
        });
        zoomOffset = {x:0,y:0};
        zoomStage = 2;
        zoom = 4;
        update();

        // Add the default image to our array only once
        if (!defaultImageLoaded && image.src.includes('test2.png')) {
            defaultImageLoaded = true;

            // Add default image to our images array
            const imageObj = {
                image: image,
                fileName: 'test2.png',
                processed: null
            };

            images.push(imageObj);
            currentImageIndex = 0;
            addImageThumbnail(imageObj, 0);
        }
    }
    image.src = './test2.png';

    function init(){

        update();
    }

    function update(){
        width = image.width;
        height = image.height;
        side = Math.max(image.width, image.height);


        displaySide = Math.max(540, Math.min(800, side*displaySize*4));
        if(mode === 'rotate'){
            viewSize = Math.round(side*size);
            canvas.width = side*size;
            canvas.height = side*size;
        } else if(mode === 'scale'){
            viewSize = Math.round(displaySide);
            canvas.width = displaySide;
            canvas.height = displaySide;
        }

        pos = {x:width, y:height};
        offset = {x:0.5,y:0.5};

        roundFix = {x:0,y:0};
        if((viewSize+image.width)%2 == 1){
            roundFix.x = 1.0;
        }
        if((viewSize+image.height)%2 == 1){
            roundFix.y = 1.0;
        }


        container.style.width = displaySide + 'px';
        container.style.height = displaySide + 'px';

        mainEl.style.maxWidth = (displaySide + 200) + 'px';
        optionsEl.style.maxWidth = (displaySide) + 'px';
        optionsEl.style.maxHeight = (displaySide) + 'px';

        arrays = {
            position: { numComponents: 2, data: [-pos.x, -pos.y, pos.x, -pos.y, -pos.x, pos.y,  -pos.x, pos.y, pos.x, -pos.y, pos.x, pos.y], },
            a_texcoord: { numComponents: 2, data: [0, 0, 1, 0, 0, 1,   0,1, 1,0, 1,1],                 },
        };
        bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);
    }


    let dropAreaEl = document.getElementById('dropArea');

    let dragging = false;
    let dragAngle = 0.0;
    let dragStartZoom = 0.0;
    let dragStartZoomOffset = zoomOffset;
    let dragStartAngle = 0.0;
    let dragStartPos = {x:0.0, y:0.0};
    dropAreaEl.addEventListener('pointerdown', (e) => {
        dragging = true;
        let rect = canvas.getBoundingClientRect();
        let cx = rect.x + rect.width/2;
        let cy = rect.y + rect.height/2;
        dragStartPos = {x: e.clientX, y: e.clientY};
        dragZoom = Math.hypot((e.clientX - cx)*0, e.clientY - cy*0);
        dragStartZoomOffset = zoomOffset;
        dragStartZoom = zoomStage;
        dragAngle = Math.atan2(e.clientY - cy, e.clientX - cx);
        dragStartAngle = angle;
        updateDrag(e);
    });
    dropAreaEl.addEventListener('wheel', (e) => {
        e.preventDefault();
        if(mode === 'rotate'){
            if(e.shiftKey){
                angle -= e.deltaY/80000;
            } else {
                angle -= e.deltaY/800;
            }
            updateAngle();
        } else if(mode === 'scale'){
            let rect = canvas.getBoundingClientRect();
            let cx = rect.x + rect.width/2;
            let cy = rect.y + rect.height/2;
            let oldZoom = zoom;
            let oldZoomStage = zoomStage;
            if(e.shiftKey){
                zoomStage -= e.deltaY/8000;
            } else {
                zoomStage -= e.deltaY/400;
            }
            let _zoom = Math.pow(zoomStage, 2);
            _zoom = Math.max(1.0, Math.min(50, _zoom));
            let deltaZoom = _zoom - oldZoom;
            zoomOffset = {
                x: zoomOffset.x + ((cx - e.clientX)/zoom) / (oldZoom / _zoom) - ((cx - e.clientX)/_zoom),
                y: zoomOffset.y + ((cy - e.clientY)/zoom) / (oldZoom / _zoom) - ((cy - e.clientY)/_zoom),
            }
            zoomOffset.x = Math.max(-width, Math.min(width, zoomOffset.x))
            zoomOffset.y = Math.max(-height, Math.min(height, zoomOffset.y))
            updateZoom();
        }
    });
    document.addEventListener('pointermove', (e) => {
        if(dragging){
            updateDrag(e);
        }
    });
    function updateDrag(e){
        if(mode === 'rotate'){
            let rect = canvas.getBoundingClientRect();
            let cx = rect.x + rect.width/2;
            let cy = rect.y + rect.height/2;
            angle = dragStartAngle + (Math.atan2(e.clientY - cy, e.clientX - cx) - dragAngle);
            updateAngle();
        } else if(mode === 'scale'){
            let rect = canvas.getBoundingClientRect();
            let cx = rect.x + rect.width/2;
            let cy = rect.y + rect.height/2;

            let newZoom = dragStartZoom + (Math.hypot((e.clientX - cx)*0, e.clientY - cy*0) - dragZoom) / 100.0;
            zoomStage = newZoom;
            // zoomOffset = {
            //     x: dragStartZoomOffset.x + (e.clientX - dragStartPos.x)/newZoom,
            //     y: dragStartZoomOffset.y + (e.clientY - dragStartPos.y)/newZoom,
            // }
            updateZoom();
        }
    }
    function updateAngle(){
        optionEls.angle.value = Math.floor((180/Math.PI) * angle + 360) % 360;
    }
    function updateZoom(){
        zoomStage = Math.max(Math.sqrt(1.0), Math.min(Math.sqrt(50), zoomStage));
        zoom = Math.pow(zoomStage, 2);
        // zoom = Math.floor(zoom * 5) / 5;
        zoom = Math.max(1.0, Math.min(50, zoom));
        optionEls.scale.value = zoom.toFixed(2);
    }
    document.addEventListener('pointerup', (e) => {
        dragging = false;
    });

    optionEls.angle.addEventListener('input', (e) => {
        if(parseFloat(e.target.value) >= 0){
            angle = parseFloat(e.target.value) * (Math.PI/180);
        }
    });
    optionEls.scale.addEventListener('input', (e) => {
        if(parseFloat(e.target.value) >= 0){
            zoom = parseFloat(e.target.value);
        }
    });

    let offMouseDownQueries = new Map();
    function offMouseDown(query, cb){
        offMouseDownQueries.set(cb, query);
    }
    document.addEventListener('mousedown', e => {
        // for(let [cb, query] of mouseDownQueries){
        //     if(e.target.matches(query)){
        //         cb(e);
        //     }
        // }
        for(let [cb, query] of offMouseDownQueries){
            if(!e.target.closest(query)){
                cb(e);
            }
        }
    });
    offMouseDown('#colorPickerContainer, .option .colorContainer', e => {
        cancelColorPicker();
    });
    function cancelColorPicker(){
        document.querySelectorAll('.option .colorContainer').forEach(el => {
            el.classList.remove('active');
        });
        colorPickerContainerEl.classList.remove('active');
        curColorOptionEl = null;
    }

    let colorPickerContainerEl = document.getElementById('colorPickerContainer');
    let colorPickerEl = document.getElementById('colorPicker');
    let colorPicker = new iro.ColorPicker('#colorPicker', {
        width: 200,
        borderWidth: 3,
        borderColor: '#fff',
        layout: [
            {component: iro.ui.Wheel},
            {component: iro.ui.Slider, options: {sliderType: 'value'}},
        ],
        layoutDirection: 'vertical'
    });
    let curColorOptionEl = null;

    colorPicker.on('color:change', color => {
        let colorString = color.alpha < 1 ? color.hex8String : color.hexString;
        document.querySelector('.colorContainer').style.backgroundColor = colorString;
        highestColor = [color.red/255, color.green/255, color.blue/255];
    });
    // colorPicker.on('input:start', e => {
    //     mouseCatchEl.classList.add('active');
    // });
    // colorPicker.on('input:end', e => {
    //     mouseCatchEl.classList.remove('active');
    // });

    document.querySelector('.colorContainer').addEventListener('click', (e) => {
        let containerEl = e.target.closest('.colorContainer');
        if(containerEl.classList.contains('active')){
            cancelColorPicker();
        } else {
            // colorPicker.color.hex8String = colorInputEl.getAttribute('value');
            containerEl.classList.add('active');
            colorPickerContainerEl.classList.add('active');
            let rect = containerEl.getBoundingClientRect();
            colorPickerContainerEl.style.left = (rect.x + window.scrollX + document.body.scrollLeft + rect.width/2) + 'px';
            colorPickerContainerEl.style.top = (rect.y + window.scrollY + document.body.scrollTop + rect.height/2) + 'px';
            // curColorOptionEl = optionEl;
        }
    });


    function dropHandler(e) {
        dropAreaEl.classList.remove('hover');
        e.preventDefault();

        // Clear existing images if user didn't hold Shift key
        if (!e.shiftKey) {
            clearImages();
        }

        if (e.dataTransfer.items) {
            for(let item of [...e.dataTransfer.items]){
                if (item.kind === 'file') {
                    loadFile(item.getAsFile());
                }
            }
        } else {
            for(let file of [...e.dataTransfer.files]){
                loadFile(file);
            }
        }
    }

    function loadFile(file){
        let fr = new FileReader();
        fr.onload = function () {
            var data = fr.result;
            var array = new Int8Array(data);

            // Create a new image object
            const newImage = new Image();
            newImage.onload = function() {
                // Add image to array
                const imageObj = {
                    image: newImage,
                    file: file,
                    fileName: file.name,
                    processed: null
                };

                images.push(imageObj);
                addImageThumbnail(imageObj, images.length - 1);

                // If this is the first image, display it
                if (images.length === 1) {
                    currentImageIndex = 0;
                    loadImageFromArray(0);
                }

                // Show download all button if we have multiple images
                if (images.length > 1) {
                    document.getElementById('downloadAll').style.display = 'block';
                }
            };
            newImage.src = fr.result;
        };
        fr.readAsDataURL(file);
    }

    function addImageThumbnail(imageObj, index) {
        const container = document.getElementById('imagesContainer');

        const thumbContainer = document.createElement('div');
        thumbContainer.className = 'thumbnail-container';
        const thumb = document.createElement('img');
        thumb.className = 'thumbnail';
        thumb.src = imageObj.image.src;
        if (index === currentImageIndex) {
            thumb.classList.add('active');
        }

        thumb.addEventListener('click', () => {
            document.querySelectorAll('.thumbnail.active').forEach(el => el.classList.remove('active'));
            thumb.classList.add('active');
            currentImageIndex = index;
            loadImageFromArray(index);
        });

        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'thumbnail-delete';
        deleteBtn.textContent = '×';
        deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            images.splice(index, 1);
            container.removeChild(thumbContainer);

            // Update all thumbnail indexes
            const thumbnails = container.querySelectorAll('.thumbnail-container');
            thumbnails.forEach((thumb, idx) => {
                thumb.querySelector('.thumbnail').onclick = () => {
                    document.querySelectorAll('.thumbnail.active').forEach(el => el.classList.remove('active'));
                    thumb.querySelector('.thumbnail').classList.add('active');
                    currentImageIndex = idx;
                    loadImageFromArray(idx);
                };
            });

            if (images.length === 0) {
                currentImageIndex = -1;
                document.getElementById('downloadAll').style.display = 'none';
            } else if (currentImageIndex === index) {
                currentImageIndex = 0;
                loadImageFromArray(0);
                thumbnails[0].querySelector('.thumbnail').classList.add('active');
            } else if (currentImageIndex > index) {
                currentImageIndex--;
            }

            if (images.length <= 1) {
                document.getElementById('downloadAll').style.display = 'none';
            }
        });

        thumbContainer.appendChild(thumb);
        thumbContainer.appendChild(deleteBtn);
        container.appendChild(thumbContainer);
    }

    function loadImageFromArray(index) {
        if (index >= 0 && index < images.length) {
            // Create a new Image to ensure proper texture loading
            image = new Image();
            image.onload = function() {
                textures = twgl.createTextures(gl, {
                    iChannel0: { src: () => image, minMag: gl.NEAREST, wrap:gl.CLAMP_TO_EDGE },
                });
                zoomOffset = {x:0,y:0};
                zoomStage = 2;
                zoom = 4;
                update();
            };
            image.src = images[index].image.src;
        }
    }

    function loadImage(url, event){
        // If not holding Shift key, clear existing images
        if (!event || !event.shiftKey) {
            clearImages();
        }

        // Create a new image object
        const newImage = new Image();
        newImage.onload = function() {
            // Add image to array
            const imageObj = {
                image: newImage,
                fileName: url.split('/').pop(),
                processed: null
            };

            images.push(imageObj);
            addImageThumbnail(imageObj, images.length - 1);

            // If this is the first image, display it
            if (images.length === 1) {
                currentImageIndex = 0;
                loadImageFromArray(0);
            }

            // Show download all button if we have multiple images
            if (images.length > 1) {
                document.getElementById('downloadAll').style.display = 'block';
            }
        };
        newImage.src = url;
    }

    function dragOverHandler(e) {
        dropAreaEl.classList.add('hover');
        e.preventDefault();
    }

    function dragLeaveHandler(e) {
        dropAreaEl.classList.remove('hover');
        e.preventDefault();
    }

    dropAreaEl.addEventListener("drop", dropHandler);
    dropAreaEl.addEventListener("dragover", dragOverHandler);
    dropAreaEl.addEventListener("dragleave", dragLeaveHandler);



    uploadEl.addEventListener('click', (e) => {
        uploadInputEl.click();
    });

    uploadInputEl.onchange = function() {
        // Clear existing images if user didn't hold Shift key
        if (!window.event.shiftKey) {
            clearImages();
        }

        if(this.files && this.files.length > 0){
            for (let i = 0; i < this.files.length; i++) {
                loadFile(this.files[i]);
            }
        }
    }


    function dlCanvas() {
        if (currentImageIndex < 0) return;

        var data;
        if(mode === 'rotate'){
            data = canvas.toDataURL('image/png');
            next(data);
        } else if(mode === 'scale'){
            EXPORT_SCALE = true;
            render();
            // canvas.style.visibility = 'hidden';
            requestAnimationFrame(() => {
                data = canvas.toDataURL('image/png');
                next(data);
                EXPORT_SCALE = false;
                update();
            });
        }

        function next(dataUrl){
            // Save processed image in the current image object
            if (images[currentImageIndex]) {
                images[currentImageIndex].processed = dataUrl;
            }

            var link = document.createElement('a');
            const fileName = images[currentImageIndex]?.fileName || 'cleanEdge';
            const fileNameWithoutExt = fileName.split('.').slice(0, -1).join('.') || fileName;
            link.download = `${fileNameWithoutExt}.png`;
            link.href = dataUrl;
            link.click();
        }
    };

    function downloadAllImages() {
        if (images.length === 0) return;

        // Save the current image index to restore it later
        const savedCurrentIndex = currentImageIndex;

        // Create a loading indicator
        const loadingEl = document.createElement('div');
        loadingEl.style.position = 'fixed';
        loadingEl.style.top = '50%';
        loadingEl.style.left = '50%';
        loadingEl.style.transform = 'translate(-50%, -50%)';
        loadingEl.style.background = 'rgba(0,0,0,0.7)';
        loadingEl.style.color = 'white';
        loadingEl.style.padding = '20px';
        loadingEl.style.borderRadius = '10px';
        loadingEl.style.zIndex = '1000';
        loadingEl.textContent = 'Processing images...';
        document.body.appendChild(loadingEl);

        // Process all images sequentially
        const zip = new JSZip();
        let currentIndex = 0;

        function processNextImage() {
            // Update loading message
            loadingEl.textContent = `Processing image ${currentIndex + 1} of ${images.length}...`;

            // Set the current image
            currentImageIndex = currentIndex;

            // Create a new copy of the image to ensure WebGL context updates
            image = new Image();
            image.onload = function() {
                textures = twgl.createTextures(gl, {
                    iChannel0: { src: () => image, minMag: gl.NEAREST, wrap:gl.CLAMP_TO_EDGE },
                });

                zoomOffset = {x:0,y:0};
                zoomStage = 2;
                zoom = 4;
                update();

                // Export the image after a delay to ensure rendering is complete
                setTimeout(() => {
                    if (mode === 'rotate') {
                        const dataUrl = canvas.toDataURL('image/png');
                        addToZip(dataUrl, currentIndex);
                    } else if (mode === 'scale') {
                        EXPORT_SCALE = true;
                        render();

                        // Wait for render to complete
                        setTimeout(() => {
                            const dataUrl = canvas.toDataURL('image/png');
                            addToZip(dataUrl, currentIndex);
                            EXPORT_SCALE = false;
                            update();
                        }, 300);
                    }
                }, 300);
            };

            image.src = images[currentIndex].image.src;
        }

        function addToZip(dataUrl, index) {
            // Convert data URL to blob
            const byteString = atob(dataUrl.split(',')[1]);
            const mimeString = dataUrl.split(',')[0].split(':')[1].split(';')[0];
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            for (let j = 0; j < byteString.length; j++) {
                ia[j] = byteString.charCodeAt(j);
            }
            const blob = new Blob([ab], {type: mimeString});

            // Add to zip
            const fileName = images[index].fileName || `image${index}`;
            const fileNameWithoutExt = fileName.split('.').slice(0, -1).join('.') || fileName;
            zip.file(`${fileNameWithoutExt}-${mode === 'rotate' ? 'rotated' : 'scaled'}.png`, blob);

            // Store processed image
            images[index].processed = dataUrl;

            // Process next image or finish
            currentIndex++;
            if (currentIndex < images.length) {
                processNextImage();
            } else {
                // Generate and download zip
                zip.generateAsync({type: 'blob'}).then(function(content) {
                    const zipLink = document.createElement('a');
                    zipLink.download = `cleanEdge-${mode === 'rotate' ? 'rotated' : 'scaled'}.zip`;
                    zipLink.href = URL.createObjectURL(content);
                    zipLink.click();

                    // Restore original image and clean up
                    currentImageIndex = savedCurrentIndex;
                    image = new Image();
                    image.onload = function() {
                        textures = twgl.createTextures(gl, {
                            iChannel0: { src: () => image, minMag: gl.NEAREST, wrap:gl.CLAMP_TO_EDGE },
                        });
                        zoomOffset = {x:0,y:0};
                        zoomStage = 2;
                        zoom = 4;
                        update();
                        document.body.removeChild(loadingEl);
                    };
                    image.src = images[savedCurrentIndex].image.src;
                });
            }
        }

        // Start processing
        processNextImage();
    }

    downloadEl.addEventListener('click', dlCanvas, false);
    document.getElementById('downloadAll').addEventListener('click', downloadAllImages, false);

    // Add JSZip library for downloading multiple files as a zip
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
    document.head.appendChild(script);

    function clearImages() {
        // Clear the images array
        images = [];
        currentImageIndex = -1;
        defaultImageLoaded = false;

        // Clear the thumbnails container
        const container = document.getElementById('imagesContainer');
        container.innerHTML = '';

        // Hide download all button
        document.getElementById('downloadAll').style.display = 'none';
    }

    // Load test.png by default when the page loads
    document.addEventListener('DOMContentLoaded', function() {
        loadImage('example/test.png', null);
    });
</script>
</html>

